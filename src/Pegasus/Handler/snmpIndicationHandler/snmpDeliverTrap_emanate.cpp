//%/////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, 2001, 2002 BMC Software, Hewlett-Packard Company, IBM,
// The Open Group, Tivoli Systems
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// THE ABOVE COPYRIGHT NOTICE AND THIS PERMISSION NOTICE SHALL BE INCLUDED IN
// ALL COPIES OR SUBSTANTIAL PORTIONS OF THE SOFTWARE. THE SOFTWARE IS PROVIDED
// "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
// LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
// PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
//==============================================================================
//
// Author: Nitin Upasani, Hewlett-Packard Company (Nitin_Upasani@hp.com)
//
// Modified By:
//
//%/////////////////////////////////////////////////////////////////////////////

#include <Pegasus/Common/Config.h>
#include <Pegasus/Common/System.h>
#include <Pegasus/Common/Destroyer.h>
#include <fcntl.h>
#include <unistd.h>
#include <ctype.h>
#include <sys/stat.h>
#include "snmpDeliverTrap_emanate.h"
#include "prnt_lib.h"

static char *sr_filename = __FILE__;

IPCFunctionP IPCfp;  /* IPC functions pointer  */

// This code should be generated by Emanate 
// Since we do not have MIB objects defined,
// just defined here to load subagent as library

// The objects internal to the agent 
ObjectInfo OidList[] = 
{
{ { 0, NULL },
#ifndef LIGHT
    NULL,
#endif /* LIGHT */
    0, 0, 0, 0,
    NULL, NULL }
};

// This code should be generated by Emanate in k_* routine
// Since we do not have MIB objects defined,
// just defined here to pass compile 

// Called by the master agent during initialization */
int k_initialize()
{
   return 1;
}

PEGASUS_NAMESPACE_BEGIN

PEGASUS_USING_STD;

snmpDeliverTrap_emanate::snmpDeliverTrap_emanate()
{

}

snmpDeliverTrap_emanate::~snmpDeliverTrap_emanate()
{

}

void snmpDeliverTrap_emanate::initialize()
{
#ifndef SR_UDS_IPC
    InitIPCArrayTCP(&IPCfp);
#else /* SR_UDS_IPC */
    InitIPCArrayUDS(&IPCfp);
#endif /* SR_UDS_IPC */

    if(InitSubagent() == -1) 
    {
	cout << "InitSubagent Failed to initialize" << endl;
	exit(1);
    }
}

void snmpDeliverTrap_emanate::deliverTrap(
    const String& trapOid,
    const String& community,
    const String& destination,
    const String& trapType,
    Array<String>& vbOids,
    Array<String>& vbTypes,
    Array<String>& vbValues)
{
    OctetString*    newValue;

    VarBind *vb = NULL;
    VarBind *vb2 = NULL;
    VarBind *vb3 = NULL;
    
    OID	    *object = NULL;

    // Initializing with Master agent
    initialize();

    // TRAP OID: getting trapOid
    ArrayDestroyer<char> _trapOid(trapOid.allocateCString());
    _trapOid.getPointer()[strlen(_trapOid.getPointer())-1] = '\0';
    OID *sendtrapOid = MakeOIDFromDot(_trapOid.getPointer());

    // Destination : converting destination into Transport
    ArrayDestroyer<char> trap_dest(destination.allocateCString());
    TransportInfo   global_ti;
    global_ti.type = SR_IP_TRANSPORT;
    global_ti.t_ipAddr = inet_addr(trap_dest.getPointer());
    global_ti.t_ipPort = htons((unsigned short)GetSNMPTrapPort());

    // Community Name
    ArrayDestroyer<char> _community(community.allocateCString());
    OctetString* community_name = MakeOctetStringFromText(
                                      _community.getPointer());

    // getting IP address of the host
    ArrayDestroyer<char> hostname(System::getHostName().allocateCString());
    char **p;
    struct hostent *hp;
    struct in_addr in;
    hp=gethostbyname(hostname.getPointer());
    p = hp->h_addr_list;
    (void)memcpy(&in.s_addr, *p, sizeof(in.s_addr));
    char* IP_string = inet_ntoa(in);
    
    // formatting agent(host) address into OctetString format
    OctetString* agent_addr;

    SR_INT32 s1, s2, s3, s4;
    SR_UINT32 ipaddr;

    // pull out each of the 4 octet values from IP address
    sscanf(IP_string,"%d.%d.%d.%d", &s1, &s2, &s3, &s4);
 
    // Probably should perform some checks on values for
    // s1, s2, s3, and s4 here to make sure values are
    // between 0 and 255
 
    // create an empty 4 length OctetString
    agent_addr = MakeOctetString(NULL,4);
 
    // fill in values for OctetString
    agent_addr->octet_ptr[0] = (unsigned char)s1;
    agent_addr->octet_ptr[1] = (unsigned char)s2;
    agent_addr->octet_ptr[2] = (unsigned char)s3;
    agent_addr->octet_ptr[3] = (unsigned char)s4;

    // specTrap from trapOid. 
    SR_INT32 genTrap = 0;
    SR_INT32 specTrap = 0;
    
    OID* enterpriseOid ;

    Array<String> standard_traps;

    standard_traps.append(String("1.3.6.1.6.3.1.1.5.1"));
    standard_traps.append(String("1.3.6.1.6.3.1.1.5.2"));
    standard_traps.append(String("1.3.6.1.6.3.1.1.5.3"));
    standard_traps.append(String("1.3.6.1.6.3.1.1.5.4"));
    standard_traps.append(String("1.3.6.1.6.3.1.1.5.5"));
    standard_traps.append(String("1.3.6.1.6.3.1.1.5.6"));

    Array<String> oids;
    String tmpoid = trapOid;

    while(tmpoid.find(".") != PEG_NOT_FOUND)
    {
        oids.append(tmpoid.subString(0, tmpoid.find(".")));
        tmpoid = tmpoid.subString(tmpoid.find(".") + 1);
    }
    oids.append(tmpoid);

    String ent;
    if (oids[oids.size()-2] == "0")
    {
        ent = oids[0];
        for (Uint8 i = 1; i < oids.size()-2; i++)
            ent = ent + "." + oids[i];
    }

    if (Contains(standard_traps, trapOid))
    {
	ent = oids[0];
	for (Uint8 i = 1; i < oids.size()-1; i++)
            ent = ent + "." + oids[i];

	ArrayDestroyer<char> gtrap(ent.allocateCString());
        genTrap = atoi(gtrap.getPointer()) - 1;
        enterpriseOid = sendtrapOid;
    }
    else
    {
	genTrap = 6;

	ent = oids[0];
	for (Uint8 i = 1; i < oids.size()-1; i++)
            ent = ent + "." + oids[i];
	ArrayDestroyer<char> strap(oids[oids.size()-1].allocateCString());
        specTrap = atoi(strap.getPointer());

        if (oids[oids.size()-2] == "0")
        {
            ent = oids[0];
	    for (Uint8 i = 1; i < oids.size()-2; i++)
		ent = ent + "." + oids[i];

	    ArrayDestroyer<char> _ent(ent.allocateCString());
            enterpriseOid = MakeOIDFromDot(_ent.getPointer());
        }
        else
        {
	    ent = oids[0];
            for (Uint8 i = 1; i < oids.size()-1; i++)
                ent = ent + "." + oids[i];

            ArrayDestroyer<char> _ent(ent.allocateCString());
            enterpriseOid = MakeOIDFromDot(_ent.getPointer());
        }
    }

    for(Uint32 i = 0; i < vbOids.size(); i++)
    {
        ArrayDestroyer<char> _vbOid(vbOids[i].allocateCString());
        ArrayDestroyer<char> _vbValue(vbValues[i].allocateCString());

	if ((object = MakeOIDFromDot(_vbOid.getPointer())) == NULL)
        {
            cout << "Invalid OID received: " << vbOids[i] << endl;
            return;
        } 

        if (vbTypes[i] == String("OctetString"))
        {
            newValue = CloneOctetString(MakeOctetStringFromText(_vbValue.getPointer()));
            if (newValue == NULL)
            {
                cout << "Invalid Value provided : " << vbValues[i] << endl;
                return;
            }
            if ((vb2 = MakeVarBindWithValue(object, 
		(OID *) NULL, 
		OCTET_PRIM_TYPE, 
		newValue)) == NULL)
            {
                cout << "Invalid OctetString value: " << vbValues[i] << endl;
                return;
            }
        }
        else
        {
            int vbvalue = atoi(_vbValue.getPointer());
            void* value = &vbvalue;

            if (newValue == NULL)
            {
                cout << "Invalid Value provided : " << vbValues[i] << endl;
                return;
            }
            if ((vb2 = MakeVarBindWithValue(object, 
		(OID *) NULL, 
		INTEGER_TYPE, 
		value)) == NULL)
            {
                cout << "Invalid Integer Value: " << vbValues[i] << endl;
                return;
            }
        }
        if (i == 0)
        {
            vb = vb2;
            vb3 = vb2;
        }
        else
        {
            vb3->next_var = vb2;
            vb3 = vb3->next_var;
        }

	FreeOID(object);
    }

    vb3->next_var = NULL;

    // Now sending the trap
    if (trapType == String("SNMPv1"))
    {
        SendNotificationToDestSMIv1Params(
            1,					// notifyType - TRAP
            genTrap,				// genTrap
            specTrap,				// specTrap
            enterpriseOid,			// enterprise
            agent_addr,				// agent_addr
            vb,					// vb
            NULL,				// contextName
            1,					// retryCount
            1,					// timeout
            community_name,			// securityName,
            SR_SECURITY_LEVEL_NOAUTH,		// securityLevel
            SR_SECURITY_MODEL_V1,		// securityModel
            &global_ti,				// Transport Info
            0);					// cfg_chk
    }
    else if (trapType == String("SNMPv2"))
    {
        SendNotificationToDestSMIv2Params(
            1,					// notifyType - NOTIFICATION
            sendtrapOid,			// snmpTrapOID
            agent_addr,				// agent_addr
            vb,					// vb
            NULL,				// contextName
            1,					// retryCount
            100,				// timeout
            community_name,			// securityName or community
            SR_SECURITY_LEVEL_NOAUTH,		// securityLevel
            SR_SECURITY_MODEL_V1,		// securityModel
            &global_ti,				// TransportInfo
            0);					// cfg_chk
        FreeVarBindList(vb);
        FreeVarBindList(vb2);
    }
    else
    {
        cout << "Trap type not supported : " << trapType << endl;
        exit(2);
    }

    FreeVarBindList(vb);
    FreeVarBindList(vb2);
    FreeVarBindList(vb3);
}

PEGASUS_NAMESPACE_END
