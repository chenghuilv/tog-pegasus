//%/////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, 2001 BMC Software, Hewlett Packard, IBM, The Open Group,
// Tivoli Systems
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to 
// deal in the Software without restriction, including without limitation the 
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or 
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// THE ABOVE COPYRIGHT NOTICE AND THIS PERMISSION NOTICE SHALL BE INCLUDED IN 
// ALL COPIES OR SUBSTANTIAL PORTIONS OF THE SOFTWARE. THE SOFTWARE IS PROVIDED
// "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
// LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR 
// PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT 
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN 
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
//==============================================================================
//
// Author: Nitin Upasani, Hewlett-Packard Company (Nitin_Upasani@hp.com)
//
// Modified By:
//
//%/////////////////////////////////////////////////////////////////////////////

#include <Pegasus/Common/Config.h>
#include <Pegasus/Common/System.h>
#include <fcntl.h>
#include <unistd.h>
#include <ctype.h>
#include <sys/stat.h>
#include "snmpDeliverTrap_emanate.h"
#include "prnt_lib.h"

PEGASUS_NAMESPACE_BEGIN

PEGASUS_USING_STD;

static char *sr_filename = __FILE__;

IPCFunctionP IPCfp;  /* IPC functions pointer  */

// This code should be generated by Emanate 
// Since we do not have MIB objects defined,
// just defined here to load subagent as library

// The objects internal to the agent 
ObjectInfo OidList[] = 
{
{ { 0, NULL },
#ifndef LIGHT
    NULL,
#endif /* LIGHT */
    0, 0, 0, 0,
    NULL, NULL }
};

// This code should be generated by Emanate in k_* routine
// Since we do not have MIB objects defined,
// just defined here to pass compile 

// Called by the master agent during initialization */
int k_initialize()
{
   return 1;
}

snmpDeliverTrap_emanate::snmpDeliverTrap_emanate()
{

}

snmpDeliverTrap_emanate::~snmpDeliverTrap_emanate()
{

}

void snmpDeliverTrap_emanate::initialize()
{
#ifndef SR_UDS_IPC
    InitIPCArrayTCP(&IPCfp);
#else /* SR_UDS_IPC */
    InitIPCArrayUDS(&IPCfp);
#endif /* SR_UDS_IPC */

    if(InitSubagent() == -1) 
    {
	cout << "InitSubagent Failed to initialize" << endl;
	exit(1);
    }
}

void snmpDeliverTrap_emanate::deliverTrap(
    const String& trapOid,
    const String& community,
    const String& destination,
    const String& trapType,
    Array<String>& vbOids,
    Array<String>& vbTypes,
    Array<String>& vbValues)
{
    OctetString*    newValue;

    VarBind *vb = NULL;
    VarBind *vb2 = NULL;
    VarBind *vb3 = NULL;
    
    OID	    *object = NULL;

    // Initializing with Master agent
    initialize();

    // TRAP OID: getting trapOid
    char* _trapOid = trapOid.allocateCString();
    OID *sendtrapOid = MakeOIDFromDot(_trapOid);

    // Destination : converting destination into Transport
    char* trap_dest = destination.allocateCString();
    TransportInfo   global_ti;
    global_ti.type = SR_IP_TRANSPORT;
    global_ti.t_ipAddr = inet_addr(trap_dest);
    global_ti.t_ipPort = htons((unsigned short)GetSNMPTrapPort());
    delete [] trap_dest;

    // Community Name
    char* _community = community.allocateCString();
    OctetString* community_name = MakeOctetStringFromText(_community);
    delete [] _community;

    // getting IP address of the host
    char* hostname = System::getHostName().allocateCString();
    char **p;
    struct hostent *hp;
    struct in_addr in;
    hp=gethostbyname(hostname);
    p = hp->h_addr_list;
    (void)memcpy(&in.s_addr, *p, sizeof(in.s_addr));
    char* IP_string = inet_ntoa(in);
    delete [] hostname;
    
    // formatting agent(host) address into OctetString format
    OctetString* agent_addr;

    SR_INT32 s1, s2, s3, s4;
    SR_UINT32 ipaddr;

    // pull out each of the 4 octet values from IP address
    sscanf(IP_string,"%d.%d.%d.%d", &s1, &s2, &s3, &s4);
 
    // Probably should perform some checks on values for
    // s1, s2, s3, and s4 here to make sure values are
    // between 0 and 255
 
    // create an empty 4 length OctetString
    agent_addr = MakeOctetString(NULL,4);
 
    // fill in values for OctetString
    agent_addr->octet_ptr[0] = (unsigned char)s1;
    agent_addr->octet_ptr[1] = (unsigned char)s2;
    agent_addr->octet_ptr[2] = (unsigned char)s3;
    agent_addr->octet_ptr[3] = (unsigned char)s4;

    // ATTN-NU-20020312 : Write code to get enterprise, genTrap and 
    // specTrap from trapOid. 

    //NU_SNMP

    SR_INT32 genTrap = 0;
    SR_INT32 specTrap = 0;
    
    OID* enterpriseOid ;

    Array<String> standard_traps;

    standard_traps.append(String("1.3.6.1.6.3.1.1.5.1"));
    standard_traps.append(String("1.3.6.1.6.3.1.1.5.2"));
    standard_traps.append(String("1.3.6.1.6.3.1.1.5.3"));
    standard_traps.append(String("1.3.6.1.6.3.1.1.5.4"));
    standard_traps.append(String("1.3.6.1.6.3.1.1.5.5"));
    standard_traps.append(String("1.3.6.1.6.3.1.1.5.6"));

    Array<String> oids;
    String tmpoid = trapOid;

    while(tmpoid.find(".") != PEG_NOT_FOUND)
    {
        oids.append(tmpoid.subString(0, tmpoid.find(".")));
        tmpoid = tmpoid.subString(tmpoid.find(".") + 1);
    }
    oids.append(tmpoid);

    String ent;
    if (oids[oids.size()-2] == "0")
    {
        ent = oids[0];
        for (Uint8 i = 1; i < oids.size()-2; i++)
            ent = ent + "." + oids[i];
    }

    if (Contains(standard_traps, trapOid))
    {
	ent = oids[0];
	for (Uint8 i = 1; i < oids.size()-1; i++)
            ent = ent + "." + oids[i];

	char* gtrap = ent.allocateCString();
        genTrap = atoi(gtrap) - 1;
        enterpriseOid = sendtrapOid;
        delete [] gtrap;
    }
    else
    {
	genTrap = 6;

	ent = oids[0];
	for (Uint8 i = 1; i < oids.size()-1; i++)
            ent = ent + "." + oids[i];
	char* strap = oids[oids.size()-1].allocateCString();
        specTrap = atoi(strap);
        delete [] strap;

        if (oids[oids.size()-2] == "0")
        {
            ent = oids[0];
	    for (Uint8 i = 1; i < oids.size()-2; i++)
		ent = ent + "." + oids[i];

	    char* _ent = ent.allocateCString();
            enterpriseOid = MakeOIDFromDot(_ent);
            delete [] _ent;
        }
        else
        {
	    ent = oids[0];
            for (Uint8 i = 1; i < oids.size()-1; i++)
                ent = ent + "." + oids[i];

            char* _ent = ent.allocateCString();
            enterpriseOid = MakeOIDFromDot(_ent);
            delete [] _ent;
        }
    }

    char* _vbOid;
    char* _vbType;
    char* _vbValue;
    
    for(Uint32 i = 0; i < vbOids.size(); i++)
    {
	_vbOid = vbOids[i].allocateCString();
	_vbType = vbTypes[i].allocateCString();
	_vbValue = vbValues[i].allocateCString();

	if ((object = MakeOIDFromDot(_vbOid)) == NULL)
        {
            cout << "Invalid OID received: " << vbOids[i] << endl;
            return;
        } 

        if (strcmp(_vbType,"OctetString") == 0)
        {
            newValue = CloneOctetString(MakeOctetStringFromText(_vbValue));
            if (newValue == NULL)
            {
                cout << "Invalid Value provided : " << vbValues[i] << endl;
                return;
            }
            if ((vb2 = MakeVarBindWithValue(object, 
		(OID *) NULL, 
		OCTET_PRIM_TYPE, 
		newValue)) == NULL)
            {
                cout << "Invalid OctetString value: " << vbValues[i] << endl;
                return;
            }
        }
        else
        {
            newValue = CloneOctetString(MakeOctetString(
		(unsigned char *) _vbValue, strlen(_vbValue)));

            if (newValue == NULL)
            {
                cout << "Invalid Value provided : " << vbValues[i] << endl;
                return;
            }
            if ((vb2 = MakeVarBindWithValue(object, 
		(OID *) NULL, 
		INTEGER_TYPE, 
		newValue)) == NULL)
            {
                cout << "Invalid Integer Value: " << vbValues[i] << endl;
                return;
            }
        }
        if (i == 0)
        {
            vb = vb2;
            vb3 = vb2;
        }
        else
        {
            vb3->next_var = vb2;
            vb3 = vb3->next_var;
        }

	FreeOID(object);
    }

    delete [] _vbType;
    delete [] _vbValue;
    delete [] _vbOid;
    
    vb3->next_var = NULL;

    // Now sending the trap
    if (trapType == String("SNMPGeneric"))
    {
        cout << genTrap << endl;
        cout << specTrap << endl;
        PrintVarBindList(vb);
        //PrintOID(enterpriseOid);
        cout << _trapOid << endl;
        cout << "Sending SNMP generic trap : " << trapOid << endl;

	do_trap(genTrap, specTrap, vb, enterpriseOid, _trapOid);
        
	FreeVarBindList(vb);
        FreeVarBindList(vb2);
    }
    else if (trapType == String("SNMPv1"))
    {
	cout << "Sending SNMPv1 Trap : " << trapOid << endl;
        SendNotificationToDestSMIv1Params(
            1,					// notifyType - TRAP
            genTrap,				// genTrap
            specTrap,				// specTrap
            enterpriseOid,			// enterprise
            agent_addr,				// agent_addr
            vb,					// vb
            NULL,				// contextName
            1,					// retryCount
            1,					// timeout
            community_name,			// securityName,
            SR_SECURITY_LEVEL_NOAUTH,		// securityLevel
            SR_SECURITY_MODEL_V1,		// securityModel
            &global_ti,				// Transport Info
            0);					// cfg_chk

        FreeVarBindList(vb);
        FreeVarBindList(vb2);
    }
    else if (trapType == String("SNMPv2"))
    {
        cout << "Sending SNMPv2 Trap : " << trapOid << endl;
        SendNotificationToDestSMIv2Params(
            2,					// notifyType - NOTIFICATION
            sendtrapOid,			// snmpTrapOID
            agent_addr,				// agent_addr
            vb,					// vb
            NULL,				// contextName
            1,					// retryCount
            100,				// timeout
            community_name,			// securityName or community
            SR_SECURITY_LEVEL_NOAUTH,		// securityLevel
            SR_SECURITY_MODEL_V1,		// securityModel
            &global_ti,				// TransportInfo
            0);					// cfg_chk
        FreeVarBindList(vb);
        FreeVarBindList(vb2);
    }
    else
    {
        cout << "Trap type not supported : " << trapType << endl;
	delete [] _trapOid;
        exit(2);
    }

    delete [] _trapOid;
}

PEGASUS_NAMESPACE_END
