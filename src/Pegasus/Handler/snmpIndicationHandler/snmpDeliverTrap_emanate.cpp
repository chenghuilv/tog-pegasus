//%/////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000, 2001 BMC Software, Hewlett Packard, IBM, The Open Group,
// Tivoli Systems
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to 
// deal in the Software without restriction, including without limitation the 
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or 
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// THE ABOVE COPYRIGHT NOTICE AND THIS PERMISSION NOTICE SHALL BE INCLUDED IN 
// ALL COPIES OR SUBSTANTIAL PORTIONS OF THE SOFTWARE. THE SOFTWARE IS PROVIDED
// "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
// LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR 
// PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT 
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN 
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
//==============================================================================
//
// Author: Nitin Upasani, Hewlett-Packard Company (Nitin_Upasani@hp.com)
//
// Modified By:
//
//%/////////////////////////////////////////////////////////////////////////////

#include <Pegasus/Common/Config.h>
#include <Pegasus/Common/System.h>
#include <fcntl.h>
#include <unistd.h>
#include <ctype.h>
#include <sys/stat.h>
#include "snmpDeliverTrap_emanate.h"
#include "prnt_lib.h"

PEGASUS_NAMESPACE_BEGIN

PEGASUS_USING_STD;

static char *sr_filename = __FILE__;

IPCFunctionP IPCfp;  /* IPC functions pointer  */

// This code should be generated by Emanate 
// Since we do not have MIB objects defined,
// just defined here to load subagent as library

// The objects internal to the agent 
ObjectInfo OidList[] = 
{
{ { 0, NULL },
#ifndef LIGHT
    NULL,
#endif /* LIGHT */
    0, 0, 0, 0,
    NULL, NULL }
};

// This code should be generated by Emanate in k_* routine
// Since we do not have MIB objects defined,
// just defined here to pass compile 

// Called by the master agent during initialization */
int k_initialize()
{
   return 1;
}

snmpDeliverTrap_emanate::snmpDeliverTrap_emanate()
{

}

snmpDeliverTrap_emanate::~snmpDeliverTrap_emanate()
{

}

void snmpDeliverTrap_emanate::initialize()
{
#ifndef SR_UDS_IPC
    InitIPCArrayTCP(&IPCfp);
#else /* SR_UDS_IPC */
    InitIPCArrayUDS(&IPCfp);
#endif /* SR_UDS_IPC */

    if(InitSubagent() == -1) 
    {
	cout << "InitSubagent Failed to initialize" << endl;
	exit(1);
    }
}

void snmpDeliverTrap_emanate::deliverTrap(
    const String& trapOid,
    const String& community,
    const String& destination,
    const String& trapType,
    Array<String>& vbOids,
    Array<String>& vbTypes,
    Array<String>& vbValues)
{
    initialize();

    //void*   newValue;
    OctetString*   newValue;
    char*   entV2Trap;
    int	    vb_link_flag = 0;

    VarBind *vb = NULL;
    VarBind *vb2 = NULL;
    VarBind *vb3 = NULL;
    
    OID	    *object = NULL;

    // getting IP address of the host
    char* hostname = System::getHostName().allocateCString();
    char **p;
    struct hostent *hp;
    struct in_addr in;
    hp=gethostbyname(hostname);
    p = hp->h_addr_list;
    (void)memcpy(&in.s_addr, *p, sizeof(in.s_addr));
    char* IP_string = inet_ntoa(in);
    
    // converting destination into Transport
    TransportInfo   global_ti;
    global_ti.type = SR_IP_TRANSPORT;
    // address to which to send trap
    global_ti.t_ipAddr = inet_addr(destination.allocateCString());
    // port to which to send trap
    global_ti.t_ipPort = htons((unsigned short)GetSNMPTrapPort());  

    // formatting agent(host) address into OctetString format
    OctetString* agent_addr;

    SR_INT32 s1, s2, s3, s4;
    SR_UINT32 ipaddr;

    // pull out each of the 4 octet values from IP address
    sscanf(IP_string,"%d.%d.%d.%d", &s1, &s2, &s3, &s4);
 
    // Probably should perform some checks on values for
    // s1, s2, s3, and s4 here to make sure values are
    // between 0 and 255
 
    // create an empty 4 length OctetString
    agent_addr = MakeOctetString(NULL,4);
 
    // fill in values for OctetString
    agent_addr->octet_ptr[0] = (unsigned char)s1;
    agent_addr->octet_ptr[1] = (unsigned char)s2;
    agent_addr->octet_ptr[2] = (unsigned char)s3;
    agent_addr->octet_ptr[3] = (unsigned char)s4;

    // ATTN-NU-20020312 : Write code to get enterprise, genTrap and 
    // specTrap from trapOid. 

    String enterprise;
    
    OID* enterpriseOid = MakeOIDFromDot(enterprise.allocateCString());
    
    // getting trap data for do_trap()
    entV2Trap = trapOid.allocateCString();

    // getting trapOid
    OID *sendtrapOid = MakeOIDFromDot(trapOid.allocateCString());

    for(Uint32 i = 0; i < vbOids.size(); i++)
    {
	if ((object = MakeOIDFromDot(vbOids[i].allocateCString())) == NULL)
        {
            cout << "Invalid OID received: " << vbOids[i] << endl;
            return;
        } 

        if (strcmp(vbTypes[i].allocateCString(),"OctetString") == 0)
        {
            newValue = CloneOctetString(MakeOctetStringFromText
                           (vbValues[i].allocateCString()));
            if (newValue == NULL)
            {
                cout << "Invalid Value provided : " << vbValues[i] << endl;
                return;
            }
            if ((vb2 = MakeVarBindWithValue(object, 
		(OID *) NULL, 
		OCTET_PRIM_TYPE, 
		newValue)) == NULL)
            {
                cout << "Invalid OctetString value: " << vbValues[i] << endl;
                return;
            }
        }
        else
        {
            newValue = CloneOctetString(MakeOctetString(
		(unsigned char *) vbValues[i].allocateCString(),
		strlen(vbValues[i].allocateCString())));

            if (newValue == NULL)
            {
                cout << "Invalid Value provided : " << vbValues[i] << endl;
                return;
            }
            if ((vb2 = MakeVarBindWithValue(object, 
		(OID *) NULL, 
		INTEGER_TYPE, 
		newValue)) == NULL)
            {
                cout << "Invalid Integer Value: " << vbValues[i] << endl;
                return;
            }
        }
        if (i == 0)
        {
            vb = vb2;
            vb3 = vb2;
        }
        else
        {
            vb3->next_var = vb2;
            vb3 = vb3->next_var;
        }

	FreeOID(object);
    }
    
    vb3->next_var = NULL;

    // Now sending the trap
    if (trapType == String("SNMPGeneric"))
    {
	do_trap(6, 4, vb2, enterpriseOid, entV2Trap);
        FreeVarBindList(vb);
        FreeVarBindList(vb2);
    }
    else if (trapType == String("SNMPv1"))
    {
        cout << "Sending SNMPv1 Trap : " << trapOid << endl;
        SendNotificationToDestSMIv1Params(
            1,					// notifyType
            6,					// genTrap
            1,					// specTrap
            enterpriseOid,			// enterprise
            agent_addr,				// agent_addr
            vb2,				// vb
            NULL,				// contextName
            1,					// retryCount
            1,					// timeout
            MakeOctetStringFromText(community.allocateCString()),	// securityName,
            SR_SECURITY_LEVEL_NOAUTH,		// securityLevel
            SR_SECURITY_MODEL_V1,		// securityModel
            &global_ti,				// Transport Info
            0);					// cfg_chk

        FreeVarBindList(vb);
        FreeVarBindList(vb2);
    }
    else if (trapType == String("SNMPv2"))
    {
        cout << "Sending SNMPv2 Trap : " << trapOid << endl;
        SendNotificationToDestSMIv2Params(
            1,					// notifyType
            sendtrapOid,			// snmpTrapOID
            agent_addr,				// agent_addr
            //vb2,				// vb
            vb,				// vb
            NULL,				// contextName
            1,					// retryCount
            100,				// timeout
            MakeOctetStringFromText(community.allocateCString()),	// securityName or community
            SR_SECURITY_LEVEL_NOAUTH,		// securityLevel
            SR_SECURITY_MODEL_V1,		// securityModel
            &global_ti,				// TransportInfo
            0);					// cfg_chk
        FreeVarBindList(vb);
        FreeVarBindList(vb2);
    }
    else
    {
        cout << "Trap type not supported : " << trapType << endl;
        exit(2);
    }
}

PEGASUS_NAMESPACE_END
