<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HTML>
<HEAD>
   <TITLE>class  ChannelHandler</TITLE>
   <META NAME="GENERATOR" CONTENT="DOC++ 3.4.7">
</HEAD>
<BODY BGCOLOR="#ffffff">

<H2>class  <A HREF="#DOC.DOCU">ChannelHandler</A></H2></H2><BLOCKQUOTE>The user of the channel module derives from the ChannelHandler class to provide implementations of the handleOpen(), handleInput(), and handleClose() methods.</BLOCKQUOTE>
<HR>

<DL>
<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   <B><A HREF="#DOC.2.1">~ChannelHandler</A></B>()
<DD><I>Virtual destructor</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   Boolean <B><A HREF="#DOC.2.2">handleOpen</A></B>(Channel* channel)
<DD><I>Called when a connection is finally established.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   Boolean <B><A HREF="#DOC.2.3">handleInput</A></B>(Channel* channel)
<DD><I>Called when the remote peer calls the Channel::write() method on the corresponding chanel.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif>virtual   void <B><A HREF="#DOC.2.4">handleClose</A></B>(Channel* channel)
<DD><I>Called when the remote peer closes the connection.</I>
</DL></P>

</DL>

<A NAME="DOC.DOCU"></A>
<HR>
<H2>Documentation</H2>
<BLOCKQUOTE>The user of the channel module derives from the ChannelHandler class
to provide implementations of the handleOpen(), handleInput(), and
handleClose() methods. These methods are called to notify the user of
input/output events which occur on the channel. For each Channel instance,
there is a corresponding ChannelHandler instance (the Channel implementation
will most likely maintain a pointer to its ChannelHandler).

<P>To illustrate when each method is called we consider and example. When a 
client connects to a server, Channel/ChannelHandler instance pairs are 
created in both process. Then the ChannelHandler::handleOpen() method is 
called in the server. Then the ChannelHandler::handleInput() method is 
called in the client. This notifies the user of the channel module that
a channel has been opened.

<P>Now suppose that the client process calls Channel::write(). This sends
a stream of bytes (specified by the argument of write()) to the server.
This causes the corresponding ChannelHandler::handleInput() method to
be called. In order to read the stream of bytes, the server must call
the read() method of channel argument.

<P>Similarly, the server may call Channel::write() which sends a 
stream of bytes back to client, causing the corresponding
ChannelHandler::handleInput() to be called. And similarly, the read() 
method of the channel argument may be invoked obtain the stream of bytes.

<P>Establishing a channel is asymmetric: the client is active and the
server is passive. But once a channel is established, all communication
occurs symmetrically: either party may initiate a write at any time causing
the other peer's ChannelHandler::handleInput() to be invoked.

<P>When a connection is closed by one peer, the handleClose() method is
called on the corresponding ChannelHandler instance in the other peer.
The handleClose() will also be closed if the remote process exits (in
TCP is referred to as hanging up).</BLOCKQUOTE>
<DL>

<A NAME="~ChannelHandler"></A>
<A NAME="DOC.2.1"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   ~ChannelHandler()</B></TT>
<DD>Virtual destructor
<DL><DT><DD></DL><P>
<A NAME="handleOpen"></A>
<A NAME="DOC.2.2"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   Boolean handleOpen(Channel* channel)</B></TT>
<DD>Called when a connection is finally established. For the client this
happens immediately after the client initiates a connection. For the
server, this happens immediately after a client connects to the 
server. Note that a distinct handler is created for each communication
end point. That is for each client/server connection there will be
two channels created on each end and this method will be called in
each. The method returns false to close the connection.
<DL><DT><DD></DL><P>
<A NAME="handleInput"></A>
<A NAME="DOC.2.3"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   Boolean handleInput(Channel* channel)</B></TT>
<DD>Called when the remote peer calls the Channel::write() method on
the corresponding chanel. The method returns false to close the 
connection.
<DL><DT><DD></DL><P>
<A NAME="handleClose"></A>
<A NAME="DOC.2.4"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   void handleClose(Channel* channel)</B></TT>
<DD>Called when the remote peer closes the connection. This method will
also be called when the remote peer process exits.
<DL><DT><DD></DL><P></DL>

<HR><DL><DT><B>This class has no child classes.</B></DL>

<DL><DT><DD></DL><P><P><I><A HREF="index.html">Alphabetic index</A></I> <I><A HREF="HIER.html">HTML hierarchy of classes</A> or <A HREF="HIERjava.html">Java</A></I></P><HR>
<BR>
This page was generated with the help of <A HREF="http://www.linuxsupportline.com/~doc++">DOC++</A>.
</BODY>
</HTML>
